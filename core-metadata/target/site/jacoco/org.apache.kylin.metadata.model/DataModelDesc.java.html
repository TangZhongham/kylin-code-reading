<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DataModelDesc.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Kylin - Core Metadata</a> &gt; <a href="index.source.html" class="el_package">org.apache.kylin.metadata.model</a> &gt; <span class="el_source">DataModelDesc.java</span></div><h1>DataModelDesc.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

package org.apache.kylin.metadata.model;

import java.io.Serializable;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Queue;
import java.util.Set;

import com.google.common.base.Strings;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.kylin.common.KylinConfig;
import org.apache.kylin.common.persistence.ResourceStore;
import org.apache.kylin.common.persistence.RootPersistentEntity;
import org.apache.kylin.common.util.StringUtil;
import org.apache.kylin.metadata.MetadataConstants;
import org.apache.kylin.metadata.model.JoinsTree.Chain;
import org.apache.kylin.metadata.project.ProjectInstance;
import org.apache.kylin.metadata.project.ProjectManager;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import org.apache.kylin.shaded.com.google.common.collect.Lists;
import org.apache.kylin.shaded.com.google.common.collect.Maps;
import org.apache.kylin.shaded.com.google.common.collect.Sets;

@SuppressWarnings(&quot;serial&quot;)
@JsonAutoDetect(fieldVisibility = Visibility.NONE, getterVisibility = Visibility.NONE, isGetterVisibility = Visibility.NONE, setterVisibility = Visibility.NONE)
public class DataModelDesc extends RootPersistentEntity {
<span class="fc" id="L59">    private static final Logger logger = LoggerFactory.getLogger(DataModelDesc.class);</span>

<span class="fc" id="L61">    public static enum TableKind implements Serializable {</span>
<span class="fc" id="L62">        FACT, LOOKUP</span>
    }

<span class="fc" id="L65">    public static enum RealizationCapacity implements Serializable {</span>
<span class="fc" id="L66">        SMALL, MEDIUM, LARGE</span>
    }

    private KylinConfig config;

    @JsonProperty(&quot;name&quot;)
    private String name;

    @JsonProperty(&quot;owner&quot;)
    private String owner;

    @JsonProperty(&quot;is_draft&quot;)
    private boolean isDraft;

    @JsonProperty(&quot;description&quot;)
    private String description;

    @JsonProperty(&quot;fact_table&quot;)
    private String rootFactTable;

    @JsonProperty(&quot;fact_table_alias&quot;)
    private String rootFactTableAlias;

    @JsonProperty(&quot;lookups&quot;)
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private JoinTableDesc[] joinTables;

    @JsonProperty(&quot;join_tables&quot;)
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private JoinTableDesc[] deprecatedLookups; // replaced by &quot;join_tables&quot; since KYLIN-1875

    @JsonProperty(&quot;dimensions&quot;)
    private List&lt;ModelDimensionDesc&gt; dimensions;

    @JsonProperty(&quot;metrics&quot;)
    private String[] metrics;

    @JsonProperty(&quot;filter_condition&quot;)
    private String filterCondition;

    @JsonProperty(&quot;partition_desc&quot;)
    PartitionDesc partitionDesc;

<span class="fc" id="L109">    @JsonProperty(&quot;capacity&quot;)</span>
    private RealizationCapacity capacity = RealizationCapacity.MEDIUM;

    @JsonProperty(&quot;projectName&quot;)
    private String projectName; //for KYLIN-4080

    // computed attributes
    private TableRef rootFactTableRef;
<span class="fc" id="L117">    private Set&lt;TableRef&gt; factTableRefs = Sets.newLinkedHashSet();</span>
<span class="fc" id="L118">    private Set&lt;TableRef&gt; lookupTableRefs = Sets.newLinkedHashSet();</span>
<span class="fc" id="L119">    private Set&lt;TableRef&gt; allTableRefs = Sets.newLinkedHashSet();</span>
<span class="fc" id="L120">    private Map&lt;String, TableRef&gt; aliasMap = Maps.newHashMap(); // alias =&gt; TableRef, a table has exactly one alias</span>
<span class="fc" id="L121">    private Map&lt;String, TableRef&gt; tableNameMap = Maps.newHashMap(); // name =&gt; TableRef, a table maybe referenced by multiple names</span>
    private JoinsTree joinsTree;

    /**
     * Error messages during resolving json metadata
     */
<span class="fc" id="L127">    private List&lt;String&gt; errors = new ArrayList&lt;String&gt;();</span>

    // don't use unless you're sure, for jackson only
<span class="fc" id="L130">    public DataModelDesc() {</span>
<span class="fc" id="L131">    }</span>

    public KylinConfig getConfig() {
<span class="fc" id="L134">        return config;</span>
    }

    @Override
    public String resourceName() {
<span class="fc" id="L139">        return name;</span>
    }

    public String getName() {
<span class="fc" id="L143">        return name;</span>
    }

    // for updating name from draft to ready
    public void setName(String name) {
<span class="fc" id="L148">        this.name = name;</span>
<span class="fc" id="L149">    }</span>

    public String getOwner() {
<span class="nc" id="L152">        return owner;</span>
    }

    public void setOwner(String owner) {
<span class="nc" id="L156">        this.owner = owner;</span>
<span class="nc" id="L157">    }</span>

    public boolean isDraft() {
<span class="fc" id="L160">        return isDraft;</span>
    }

    public void setDraft(boolean isDraft) {
<span class="nc" id="L164">        this.isDraft = isDraft;</span>
<span class="nc" id="L165">    }</span>

    public String getDescription() {
<span class="nc" id="L168">        return description;</span>
    }

    public void setDescription(String description) {
<span class="nc" id="L172">        this.description = description;</span>
<span class="nc" id="L173">    }</span>

    public TableRef getRootFactTable() {
<span class="fc" id="L176">        return rootFactTableRef;</span>
    }

    public String getRootFactTableName() {
<span class="nc" id="L180">        return rootFactTable;</span>
    }

    public void setRootFactTableName(String rootFactTable) {
<span class="nc" id="L184">        this.rootFactTable = rootFactTable;</span>
<span class="nc" id="L185">    }</span>

    public Set&lt;TableRef&gt; getAllTables() {
<span class="fc" id="L188">        return allTableRefs;</span>
    }

    public Set&lt;TableRef&gt; getFactTables() {
<span class="nc" id="L192">        return factTableRefs;</span>
    }

    public Map&lt;String, TableRef&gt; getAliasMap() {
<span class="nc" id="L196">        return Collections.unmodifiableMap(aliasMap);</span>
    }

    public Set&lt;TableRef&gt; getLookupTables() {
<span class="nc" id="L200">        return lookupTableRefs;</span>
    }

    public JoinTableDesc[] getJoinTables() {
<span class="fc" id="L204">        return joinTables;</span>
    }

    public void setJoinTables(JoinTableDesc[] joinTables) {
<span class="nc" id="L208">        this.joinTables = joinTables;</span>
<span class="nc" id="L209">    }</span>

    public JoinDesc getJoinByPKSide(TableRef table) {
<span class="nc" id="L212">        return joinsTree.getJoinByPKSide(table);</span>
    }

    public JoinsTree getJoinsTree() {
<span class="fc" id="L216">        return joinsTree;</span>
    }

    @Deprecated
    public List&lt;TableDesc&gt; getLookupTableDescs() {
<span class="nc" id="L221">        List&lt;TableDesc&gt; result = Lists.newArrayList();</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        for (TableRef table : getLookupTables()) {</span>
<span class="nc" id="L223">            result.add(table.getTableDesc());</span>
<span class="nc" id="L224">        }</span>
<span class="nc" id="L225">        return result;</span>
    }

    public boolean isLookupTable(TableRef t) {
<span class="nc bnc" id="L229" title="All 2 branches missed.">        if (t == null)</span>
<span class="nc" id="L230">            return false;</span>
        else
<span class="nc" id="L232">            return lookupTableRefs.contains(t);</span>
    }

    public boolean isLookupTable(String fullTableName) {
<span class="nc bnc" id="L236" title="All 2 branches missed.">        for (TableRef t : lookupTableRefs) {</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">            if (t.getTableIdentity().equals(fullTableName))</span>
<span class="nc" id="L238">                return true;</span>
<span class="nc" id="L239">        }</span>
<span class="nc" id="L240">        return false;</span>
    }

    public boolean isFactTable(TableRef t) {
<span class="nc bnc" id="L244" title="All 2 branches missed.">        if (t == null)</span>
<span class="nc" id="L245">            return false;</span>
        else
<span class="nc" id="L247">            return factTableRefs.contains(t);</span>
    }

    //TODO: different from isFactTable(TableRef t) 
    public boolean isFactTable(String fullTableName) {
<span class="fc bfc" id="L252" title="All 2 branches covered.">        for (TableRef t : factTableRefs) {</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">            if (t.getTableIdentity().equals(fullTableName))</span>
<span class="fc" id="L254">                return true;</span>
<span class="fc" id="L255">        }</span>
<span class="fc" id="L256">        return false;</span>
    }

    public boolean containsTable(TableDesc table) {
<span class="nc bnc" id="L260" title="All 2 branches missed.">        for (TableRef t : allTableRefs) {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">            if (t.getTableIdentity().equals(table.getIdentity())</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                    &amp;&amp; StringUtil.equals(t.getTableDesc().getProject(), table.getProject()))</span>
<span class="nc" id="L263">                return true;</span>
<span class="nc" id="L264">        }</span>
<span class="nc" id="L265">        return false;</span>
    }

    public String getFilterCondition() {
<span class="nc" id="L269">        return filterCondition;</span>
    }

    public void setFilterCondition(String filterCondition) {
<span class="nc" id="L273">        this.filterCondition = filterCondition;</span>
<span class="nc" id="L274">    }</span>

    public PartitionDesc getPartitionDesc() {
<span class="fc" id="L277">        return partitionDesc;</span>
    }

    public void setPartitionDesc(PartitionDesc partitionDesc) {
<span class="fc" id="L281">        this.partitionDesc = partitionDesc;</span>
<span class="fc" id="L282">    }</span>

    public RealizationCapacity getCapacity() {
<span class="nc" id="L285">        return capacity;</span>
    }

    public void setCapacity(RealizationCapacity capacity) {
<span class="nc" id="L289">        this.capacity = capacity;</span>
<span class="nc" id="L290">    }</span>

    public TblColRef findColumn(String table, String column) throws IllegalArgumentException {
<span class="fc" id="L293">        TblColRef result = null;</span>
<span class="fc" id="L294">        TableRef tableRef = findTable(table);</span>
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (Objects.nonNull(tableRef)) {</span>
<span class="fc" id="L296">            result = tableRef.getColumn(column.toUpperCase(Locale.ROOT));;</span>
        }

<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (result == null) {//tiretree global domain dic</span>
<span class="nc" id="L300">            logger.warn(&quot;table {} column {} not found in its's model {} , maybe it's a tiretree global domain dict. &quot;, table, column, getName() );</span>
        }

<span class="fc" id="L303">        return result;</span>
    }

    public TblColRef findColumn(String column) throws IllegalArgumentException {
<span class="fc" id="L307">        TblColRef result = null;</span>
<span class="fc" id="L308">        String input = column;</span>

<span class="fc" id="L310">        column = column.toUpperCase(Locale.ROOT);</span>
<span class="fc" id="L311">        int cut = column.lastIndexOf('.');</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        if (cut &gt; 0) {</span>
            // table specified
<span class="fc" id="L314">            result = findColumn(column.substring(0, cut), column.substring(cut + 1));</span>
        } else {
            // table not specified, try each table
<span class="pc bpc" id="L317" title="1 of 2 branches missed.">            for (TableRef tableRef : allTableRefs) {</span>
<span class="fc" id="L318">                result = tableRef.getColumn(column);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">                if (result != null)</span>
<span class="fc" id="L320">                    break;</span>
<span class="fc" id="L321">            }</span>
        }

<span class="pc bpc" id="L324" title="1 of 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L325">            logger.warn(&quot;Column {} not found in its's model {} , maybe it's a tiretree global domain dict. &quot;, column, getName() );</span>
        }

<span class="fc" id="L328">        return result;</span>
    }

    // find by unique name, that must uniquely identifies a table in the model
    public TableRef findTable(String table) throws IllegalArgumentException {
<span class="fc" id="L333">        TableRef result = tableNameMap.get(table.toUpperCase(Locale.ROOT));</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L335">            logger.warn(&quot;table {} not found in its's model {} , maybe it's a tiretree global domain dict. &quot;, table, getName() );</span>
        }
<span class="fc" id="L337">        return result;</span>
    }

    // find by table identity, that may match multiple tables in the model
    public TableRef findFirstTable(String tableIdentity) throws IllegalArgumentException {
<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (rootFactTableRef.getTableIdentity().equals(tableIdentity))</span>
<span class="nc" id="L343">            return rootFactTableRef;</span>

<span class="nc bnc" id="L345" title="All 2 branches missed.">        for (TableRef fact : factTableRefs) {</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">            if (fact.getTableIdentity().equals(tableIdentity))</span>
<span class="nc" id="L347">                return fact;</span>
<span class="nc" id="L348">        }</span>

<span class="nc bnc" id="L350" title="All 2 branches missed.">        for (TableRef lookup : lookupTableRefs) {</span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">            if (lookup.getTableIdentity().equals(tableIdentity))</span>
<span class="nc" id="L352">                return lookup;</span>
<span class="nc" id="L353">        }</span>
<span class="nc" id="L354">        throw new IllegalArgumentException(&quot;Table not found by &quot; + tableIdentity + &quot; in model &quot; + name);</span>
    }

    /**
     * @param isOnlineModel will affect the exposed view of project specific tables
     */
    public void init(KylinConfig config, Map&lt;String, TableDesc&gt; tables) {
<span class="fc" id="L361">        initInternal(config, tables);</span>
<span class="fc" id="L362">    }</span>

    public void initInternal(KylinConfig config, Map&lt;String, TableDesc&gt; tables) {
<span class="fc" id="L365">        this.config = config;</span>

<span class="fc" id="L367">        initJoinTablesForUpgrade();</span>
<span class="fc" id="L368">        initTableAlias(tables);</span>
<span class="fc" id="L369">        initJoinColumns();</span>
<span class="fc" id="L370">        reorderJoins(tables);</span>
<span class="fc" id="L371">        initJoinsTree();</span>
<span class="fc" id="L372">        initDimensionsAndMetrics();</span>
<span class="fc" id="L373">        initPartitionDesc();</span>
<span class="fc" id="L374">        initFilterCondition();</span>

<span class="fc" id="L376">        boolean reinit = validate();</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">        if (reinit) { // model slightly changed by validate() and must init() again</span>
<span class="nc" id="L378">            initInternal(config, tables);</span>
        }
<span class="fc" id="L380">    }</span>

    private void initJoinTablesForUpgrade() {
<span class="fc bfc" id="L383" title="All 2 branches covered.">        if (joinTables == null) {</span>
<span class="fc" id="L384">            joinTables = new JoinTableDesc[0];</span>
        }
<span class="fc bfc" id="L386" title="All 2 branches covered.">        if (deprecatedLookups != null) {</span>
<span class="fc" id="L387">            JoinTableDesc[] copy = Arrays.copyOf(joinTables, joinTables.length + deprecatedLookups.length);</span>
<span class="fc" id="L388">            System.arraycopy(deprecatedLookups, 0, copy, joinTables.length, deprecatedLookups.length);</span>
<span class="fc" id="L389">            joinTables = copy;</span>
<span class="fc" id="L390">            deprecatedLookups = null;</span>
        }
<span class="fc" id="L392">    }</span>

    private void initTableAlias(Map&lt;String, TableDesc&gt; tables) {
<span class="fc" id="L395">        factTableRefs.clear();</span>
<span class="fc" id="L396">        lookupTableRefs.clear();</span>
<span class="fc" id="L397">        allTableRefs.clear();</span>
<span class="fc" id="L398">        aliasMap.clear();</span>
<span class="fc" id="L399">        tableNameMap.clear();</span>

<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        if (StringUtils.isEmpty(rootFactTable)) {</span>
<span class="nc" id="L402">            throw new IllegalStateException(&quot;root fact table should not be empty&quot;);</span>
        }

<span class="fc" id="L405">        rootFactTable = rootFactTable.toUpperCase(Locale.ROOT);</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (tables.containsKey(rootFactTable) == false)</span>
<span class="nc" id="L407">            throw new IllegalStateException(&quot;Root fact table does not exist:&quot; + rootFactTable);</span>

<span class="fc" id="L409">        TableDesc rootDesc = tables.get(rootFactTable);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">        if (Strings.isNullOrEmpty(rootFactTableAlias)) {</span>
<span class="fc" id="L411">            rootFactTableAlias = rootDesc.getName();</span>
        }
<span class="fc" id="L413">        rootFactTableRef = new TableRef(this, rootFactTableAlias, rootDesc, false);</span>

<span class="fc" id="L415">        addAlias(rootFactTableRef);</span>
<span class="fc" id="L416">        factTableRefs.add(rootFactTableRef);</span>

<span class="fc bfc" id="L418" title="All 2 branches covered.">        for (JoinTableDesc join : joinTables) {</span>
<span class="fc" id="L419">            join.setTable(join.getTable().toUpperCase(Locale.ROOT));</span>

<span class="pc bpc" id="L421" title="1 of 2 branches missed.">            if (tables.containsKey(join.getTable()) == false)</span>
<span class="nc" id="L422">                throw new IllegalStateException(&quot;Join table does not exist:&quot; + join.getTable());</span>

<span class="fc" id="L424">            TableDesc tableDesc = tables.get(join.getTable());</span>
<span class="fc" id="L425">            String alias = join.getAlias();</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">            if (alias == null) {</span>
<span class="fc" id="L427">                alias = tableDesc.getName();</span>
            }
<span class="fc" id="L429">            alias = alias.toUpperCase(Locale.ROOT);</span>
<span class="fc" id="L430">            join.setAlias(alias);</span>

<span class="fc bfc" id="L432" title="All 2 branches covered.">            boolean isLookup = join.getKind() == TableKind.LOOKUP;</span>
<span class="fc" id="L433">            TableRef ref = new TableRef(this, alias, tableDesc, isLookup);</span>

<span class="fc" id="L435">            join.setTableRef(ref);</span>
<span class="fc" id="L436">            addAlias(ref);</span>
<span class="fc bfc" id="L437" title="All 2 branches covered.">            (isLookup ? lookupTableRefs : factTableRefs).add(ref);</span>
        }

<span class="fc" id="L440">        tableNameMap.putAll(aliasMap);</span>
<span class="fc" id="L441">        allTableRefs.addAll(factTableRefs);</span>
<span class="fc" id="L442">        allTableRefs.addAll(lookupTableRefs);</span>
<span class="fc" id="L443">    }</span>

    private void addAlias(TableRef ref) {
<span class="fc" id="L446">        String alias = ref.getAlias();</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">        if (aliasMap.containsKey(alias))</span>
<span class="nc" id="L448">            throw new IllegalStateException(&quot;Alias '&quot; + alias + &quot;' ref to multiple tables: &quot; + ref.getTableIdentity()</span>
<span class="nc" id="L449">                    + &quot;, &quot; + aliasMap.get(alias).getTableIdentity());</span>
<span class="fc" id="L450">        aliasMap.put(alias, ref);</span>

<span class="fc" id="L452">        TableDesc table = ref.getTableDesc();</span>
<span class="fc" id="L453">        addTableName(table.getName(), ref);</span>
<span class="fc" id="L454">        addTableName(table.getIdentity(), ref);</span>
<span class="fc" id="L455">    }</span>

    private void addTableName(String name, TableRef ref) {
<span class="fc bfc" id="L458" title="All 2 branches covered.">        if (tableNameMap.containsKey(name)) {</span>
<span class="fc" id="L459">            tableNameMap.put(name, null); // conflict name</span>
        } else {
<span class="fc" id="L461">            tableNameMap.put(name, ref);</span>
        }
<span class="fc" id="L463">    }</span>

    private void initDimensionsAndMetrics() {
<span class="fc bfc" id="L466" title="All 2 branches covered.">        for (ModelDimensionDesc dim : dimensions) {</span>
<span class="fc" id="L467">            dim.init(this);</span>
<span class="fc" id="L468">        }</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">        for (int i = 0; i &lt; metrics.length; i++) {</span>
<span class="fc" id="L470">            metrics[i] = findColumn(metrics[i]).getIdentity();</span>
        }
<span class="fc" id="L472">    }</span>

    private void initPartitionDesc() {
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">        if (this.partitionDesc != null)</span>
<span class="fc" id="L476">            this.partitionDesc.init(this);</span>
<span class="fc" id="L477">    }</span>

    //Check if the filter condition is illegal.  
    private void initFilterCondition() {
<span class="fc bfc" id="L481" title="All 2 branches covered.">        if (null == this.filterCondition) {</span>
<span class="fc" id="L482">            return;</span>
        }
<span class="fc" id="L484">        int quotationType = 0;</span>
<span class="fc" id="L485">        int len = this.filterCondition.length();</span>
<span class="pc bpc" id="L486" title="1 of 2 branches missed.">        for (int i = 0; i &lt; len; i++) {</span>
            //If a ';' which is not within a string is found, throw exception. 
<span class="nc bnc" id="L488" title="All 4 branches missed.">            if (';' == this.filterCondition.charAt(i) &amp;&amp; 0 == quotationType) {</span>
<span class="nc" id="L489">                throw new IllegalStateException(</span>
                        &quot;Filter Condition is Illegal. Please check it and make sure it's an appropriate expression for WHERE clause&quot;);
            }
<span class="nc bnc" id="L492" title="All 2 branches missed.">            if ('\'' == this.filterCondition.charAt(i)) {</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                if (quotationType &gt; 0) {</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">                    if (1 == quotationType) {</span>
<span class="nc" id="L495">                        quotationType = 0;</span>
<span class="nc" id="L496">                        continue;</span>
                    }
                } else {
<span class="nc bnc" id="L499" title="All 2 branches missed.">                    if (0 == quotationType) {</span>
<span class="nc" id="L500">                        quotationType = 1;</span>
<span class="nc" id="L501">                        continue;</span>
                    }
                }
            }
<span class="nc bnc" id="L505" title="All 2 branches missed.">            if ('&quot;' == this.filterCondition.charAt(i)) {</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">                if (quotationType &gt; 0) {</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">                    if (2 == quotationType) {</span>
<span class="nc" id="L508">                        quotationType = 0;</span>
<span class="nc" id="L509">                        continue;</span>
                    }
                } else {
<span class="nc bnc" id="L512" title="All 2 branches missed.">                    if (0 == quotationType) {</span>
<span class="nc" id="L513">                        quotationType = 2;</span>
                        continue;
                    }
                }
            }
        }
<span class="fc" id="L519">    }</span>

    private void initJoinColumns() {

<span class="fc bfc" id="L523" title="All 2 branches covered.">        for (JoinTableDesc joinTable : joinTables) {</span>
<span class="fc" id="L524">            TableRef dimTable = joinTable.getTableRef();</span>
<span class="fc" id="L525">            JoinDesc join = joinTable.getJoin();</span>
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">            if (join == null)</span>
<span class="nc" id="L527">                throw new IllegalStateException(&quot;Missing join conditions on table &quot; + dimTable);</span>

<span class="fc" id="L529">            StringUtil.toUpperCaseArray(join.getForeignKey(), join.getForeignKey());</span>
<span class="fc" id="L530">            StringUtil.toUpperCaseArray(join.getPrimaryKey(), join.getPrimaryKey());</span>

            // primary key
<span class="fc" id="L533">            String[] pks = join.getPrimaryKey();</span>
<span class="fc" id="L534">            TblColRef[] pkCols = new TblColRef[pks.length];</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">            for (int i = 0; i &lt; pks.length; i++) {</span>
<span class="fc" id="L536">                TblColRef col = dimTable.getColumn(pks[i]);</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">                if (col == null) {</span>
<span class="fc" id="L538">                    col = findColumn(pks[i]);</span>
                }
<span class="pc bpc" id="L540" title="2 of 4 branches missed.">                if (col == null || col.getTableRef().equals(dimTable) == false) {</span>
<span class="nc" id="L541">                    throw new IllegalStateException(&quot;Can't find PK column &quot; + pks[i] + &quot; in table &quot; + dimTable);</span>
                }
<span class="fc" id="L543">                pks[i] = col.getIdentity();</span>
<span class="fc" id="L544">                pkCols[i] = col;</span>
            }
<span class="fc" id="L546">            join.setPrimaryKeyColumns(pkCols);</span>

            // foreign key
<span class="fc" id="L549">            String[] fks = join.getForeignKey();</span>
<span class="fc" id="L550">            TblColRef[] fkCols = new TblColRef[fks.length];</span>
<span class="fc bfc" id="L551" title="All 2 branches covered.">            for (int i = 0; i &lt; fks.length; i++) {</span>
<span class="fc" id="L552">                TblColRef col = findColumn(fks[i]);</span>
<span class="pc bpc" id="L553" title="1 of 2 branches missed.">                if (col == null) {</span>
<span class="nc" id="L554">                    throw new IllegalStateException(&quot;Can't find FK column &quot; + fks[i]);</span>
                }
<span class="fc" id="L556">                fks[i] = col.getIdentity();</span>
<span class="fc" id="L557">                fkCols[i] = col;</span>
            }
<span class="fc" id="L559">            join.setForeignKeyColumns(fkCols);</span>

<span class="fc" id="L561">            join.sortByFK();</span>

            // Validate join in dimension
<span class="fc" id="L564">            TableRef fkTable = fkCols[0].getTableRef();</span>
<span class="pc bpc" id="L565" title="2 of 4 branches missed.">            if (pkCols.length == 0 || fkCols.length == 0)</span>
<span class="nc" id="L566">                throw new IllegalStateException(&quot;Missing join columns on table &quot; + dimTable);</span>
<span class="pc bpc" id="L567" title="1 of 2 branches missed.">            if (pkCols.length != fkCols.length) {</span>
<span class="nc" id="L568">                throw new IllegalStateException(&quot;Primary keys(&quot; + dimTable + &quot;)&quot; + Arrays.toString(pks)</span>
<span class="nc" id="L569">                        + &quot; are not consistent with Foreign keys(&quot; + fkTable + &quot;) &quot; + Arrays.toString(fks));</span>
            }
<span class="fc bfc" id="L571" title="All 2 branches covered.">            for (int i = 0; i &lt; fkCols.length; i++) {</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">                if (!fkCols[i].getDatatype().equals(pkCols[i].getDatatype())) {</span>
<span class="fc" id="L573">                    logger.warn(&quot;PK &quot; + dimTable + &quot;.&quot; + pkCols[i].getName() + &quot;.&quot; + pkCols[i].getDatatype()</span>
<span class="fc" id="L574">                            + &quot; are not consistent with FK &quot; + fkTable + &quot;.&quot; + fkCols[i].getName() + &quot;.&quot;</span>
<span class="fc" id="L575">                            + fkCols[i].getDatatype());</span>
                }
            }
        }
<span class="fc" id="L579">    }</span>

    private void initJoinsTree() {
<span class="fc" id="L582">        List&lt;JoinDesc&gt; joins = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">        for (JoinTableDesc joinTable : joinTables) {</span>
<span class="fc" id="L584">            joins.add(joinTable.getJoin());</span>
        }
<span class="fc" id="L586">        joinsTree = new JoinsTree(rootFactTableRef, joins);</span>
<span class="fc" id="L587">    }</span>

    private void reorderJoins(Map&lt;String, TableDesc&gt; tables) {
<span class="fc bfc" id="L590" title="All 2 branches covered.">        if (joinTables.length == 0) {</span>
<span class="fc" id="L591">            return;</span>
        }

<span class="fc" id="L594">        Map&lt;String, List&lt;JoinTableDesc&gt;&gt; fkMap = Maps.newHashMap();</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">        for (JoinTableDesc joinTable : joinTables) {</span>
<span class="fc" id="L596">            JoinDesc join = joinTable.getJoin();</span>
<span class="fc" id="L597">            String fkSideName = join.getFKSide().getAlias();</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">            if (fkMap.containsKey(fkSideName)) {</span>
<span class="fc" id="L599">                fkMap.get(fkSideName).add(joinTable);</span>
            } else {
<span class="fc" id="L601">                List&lt;JoinTableDesc&gt; joinTableList = Lists.newArrayList();</span>
<span class="fc" id="L602">                joinTableList.add(joinTable);</span>
<span class="fc" id="L603">                fkMap.put(fkSideName, joinTableList);</span>
            }
        }

<span class="fc" id="L607">        JoinTableDesc[] orderedJoinTables = new JoinTableDesc[joinTables.length];</span>
<span class="fc" id="L608">        int orderedIndex = 0;</span>

<span class="fc" id="L610">        Queue&lt;JoinTableDesc&gt; joinTableBuff = new ArrayDeque&lt;JoinTableDesc&gt;();</span>
<span class="fc" id="L611">        joinTableBuff.addAll(fkMap.get(rootFactTableAlias));</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">        while (!joinTableBuff.isEmpty()) {</span>
<span class="fc" id="L613">            JoinTableDesc head = joinTableBuff.poll();</span>
<span class="fc" id="L614">            orderedJoinTables[orderedIndex++] = head;</span>
<span class="fc" id="L615">            String headAlias = head.getJoin().getPKSide().getAlias();</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">            if (fkMap.containsKey(headAlias)) {</span>
<span class="fc" id="L617">                joinTableBuff.addAll(fkMap.get(headAlias));</span>
            }
<span class="fc" id="L619">        }</span>

<span class="fc" id="L621">        joinTables = orderedJoinTables;</span>
<span class="fc" id="L622">    }</span>

    private boolean validate() {

        // ensure no dup between dimensions/metrics
<span class="fc bfc" id="L627" title="All 2 branches covered.">        for (ModelDimensionDesc dim : dimensions) {</span>
<span class="fc" id="L628">            String table = dim.getTable();</span>
<span class="fc bfc" id="L629" title="All 2 branches covered.">            for (String c : dim.getColumns()) {</span>
<span class="fc" id="L630">                TblColRef dcol = findColumn(table, c);</span>
<span class="fc" id="L631">                metrics = ArrayUtils.removeElement(metrics, dcol.getIdentity());</span>
            }
<span class="fc" id="L633">        }</span>

<span class="fc" id="L635">        Set&lt;TblColRef&gt; mcols = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L636" title="All 2 branches covered.">        for (String m : metrics) {</span>
<span class="fc" id="L637">            mcols.add(findColumn(m));</span>
        }

        // validate PK/FK are in dimensions
<span class="fc" id="L641">        boolean pkfkDimAmended = false;</span>
<span class="fc bfc" id="L642" title="All 2 branches covered.">        for (Chain chain : joinsTree.getTableChains().values()) {</span>
<span class="pc bpc" id="L643" title="2 of 4 branches missed.">            pkfkDimAmended = validatePkFkDim(chain.join, mcols) || pkfkDimAmended;</span>
<span class="fc" id="L644">        }</span>
<span class="fc" id="L645">        return pkfkDimAmended;</span>
    }

    private boolean validatePkFkDim(JoinDesc join, Set&lt;TblColRef&gt; mcols) {
<span class="fc bfc" id="L649" title="All 2 branches covered.">        if (join == null)</span>
<span class="fc" id="L650">            return false;</span>

<span class="fc" id="L652">        boolean pkfkDimAmended = false;</span>

<span class="fc bfc" id="L654" title="All 2 branches covered.">        for (TblColRef c : join.getForeignKeyColumns()) {</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">            if (!mcols.contains(c)) {</span>
<span class="pc bpc" id="L656" title="2 of 4 branches missed.">                pkfkDimAmended = validatePkFkDim(c) || pkfkDimAmended;</span>
            }
        }
<span class="fc bfc" id="L659" title="All 2 branches covered.">        for (TblColRef c : join.getPrimaryKeyColumns()) {</span>
<span class="pc bpc" id="L660" title="1 of 2 branches missed.">            if (!mcols.contains(c)) {</span>
<span class="pc bpc" id="L661" title="2 of 4 branches missed.">                pkfkDimAmended = validatePkFkDim(c) || pkfkDimAmended;</span>
            }
        }
<span class="fc" id="L664">        return pkfkDimAmended;</span>
    }

    private boolean validatePkFkDim(TblColRef c) {
<span class="fc" id="L668">        String t = c.getTableAlias();</span>
<span class="fc" id="L669">        ModelDimensionDesc dimDesc = null;</span>
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">        for (ModelDimensionDesc dim : dimensions) {</span>
<span class="fc bfc" id="L671" title="All 2 branches covered.">            if (dim.getTable().equals(t)) {</span>
<span class="fc" id="L672">                dimDesc = dim;</span>
<span class="fc" id="L673">                break;</span>
            }
<span class="fc" id="L675">        }</span>

<span class="pc bpc" id="L677" title="1 of 2 branches missed.">        if (dimDesc == null) {</span>
<span class="nc" id="L678">            dimDesc = new ModelDimensionDesc();</span>
<span class="nc" id="L679">            dimDesc.setTable(t);</span>
<span class="nc" id="L680">            dimDesc.setColumns(new String[0]);</span>
<span class="nc" id="L681">            dimensions.add(dimDesc);</span>
        }

<span class="pc bpc" id="L684" title="1 of 2 branches missed.">        if (ArrayUtils.contains(dimDesc.getColumns(), c.getName()) == false) {</span>
<span class="nc" id="L685">            String[] newCols = ArrayUtils.add(dimDesc.getColumns(), c.getName());</span>
<span class="nc" id="L686">            dimDesc.setColumns(newCols);</span>
<span class="nc" id="L687">            return true;</span>
        }

<span class="fc" id="L690">        return false;</span>
    }

    public boolean isStandardPartitionedDateColumn() {
<span class="nc bnc" id="L694" title="All 2 branches missed.">        if (StringUtils.isBlank(getPartitionDesc().getPartitionDateFormat())) {</span>
<span class="nc" id="L695">            return false;</span>
        }
<span class="nc" id="L697">        return true;</span>
    }

    /**
     * Add error info and thrown exception out
     */
    public void addError(String message) {
<span class="nc" id="L704">        addError(message, false);</span>
<span class="nc" id="L705">    }</span>

    /**
     * @param message error message
     * @param silent  if throw exception
     */
    public void addError(String message, boolean silent) {
<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (!silent) {</span>
<span class="nc" id="L713">            throw new IllegalStateException(message);</span>
        } else {
<span class="nc" id="L715">            this.errors.add(message);</span>
        }
<span class="nc" id="L717">    }</span>

    public List&lt;String&gt; getError() {
<span class="nc" id="L720">        return this.errors;</span>
    }

    private Map&lt;String, JoinTableDesc&gt; getJoinTableMap(JoinTableDesc[] joinTables) {
<span class="nc bnc" id="L724" title="All 2 branches missed.">        if (joinTables == null) {</span>
<span class="nc" id="L725">            return Maps.newHashMap();</span>
        }
<span class="nc" id="L727">        Map&lt;String, JoinTableDesc&gt; ret = Maps.newHashMapWithExpectedSize(joinTables.length);</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">        for (JoinTableDesc joinTable : joinTables) {</span>
<span class="nc" id="L729">            ret.put(joinTable.getAlias(), joinTable);</span>
        }
<span class="nc" id="L731">        return ret;</span>
    }

    public boolean equalsRaw(Object o) {
<span class="nc bnc" id="L735" title="All 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L736">            return true;</span>
<span class="nc bnc" id="L737" title="All 4 branches missed.">        if (o == null || getClass() != o.getClass())</span>
<span class="nc" id="L738">            return false;</span>

<span class="nc" id="L740">        DataModelDesc that = (DataModelDesc) o;</span>

<span class="nc bnc" id="L742" title="All 2 branches missed.">        if (isDraft != that.isDraft)</span>
<span class="nc" id="L743">            return false;</span>
<span class="nc bnc" id="L744" title="All 6 branches missed.">        if (name != null ? !name.equals(that.name) : that.name != null)</span>
<span class="nc" id="L745">            return false;</span>
<span class="nc bnc" id="L746" title="All 6 branches missed.">        if (owner != null ? !owner.equals(that.owner) : that.owner != null)</span>
<span class="nc" id="L747">            return false;</span>
<span class="nc bnc" id="L748" title="All 6 branches missed.">        if (description != null ? !description.equals(that.description) : that.description != null)</span>
<span class="nc" id="L749">            return false;</span>
<span class="nc bnc" id="L750" title="All 6 branches missed.">        if (rootFactTable != null ? !rootFactTable.equals(that.rootFactTable) : that.rootFactTable != null)</span>
<span class="nc" id="L751">            return false;</span>
<span class="nc bnc" id="L752" title="All 6 branches missed.">        if (rootFactTableAlias != null ? !rootFactTableAlias.equals(that.rootFactTableAlias)</span>
                : that.rootFactTableAlias != null)
<span class="nc" id="L754">            return false;</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">        if (!getJoinTableMap(joinTables).equals(getJoinTableMap(that.joinTables)))</span>
<span class="nc" id="L756">            return false;</span>
<span class="nc bnc" id="L757" title="All 6 branches missed.">        if (dimensions != null ? !dimensions.equals(that.dimensions) : that.dimensions != null)</span>
<span class="nc" id="L758">            return false;</span>
        // Probably incorrect - comparing Object[] arrays with Arrays.equals
<span class="nc bnc" id="L760" title="All 2 branches missed.">        if (!Arrays.equals(metrics, that.metrics))</span>
<span class="nc" id="L761">            return false;</span>
<span class="nc bnc" id="L762" title="All 6 branches missed.">        if (filterCondition != null ? !filterCondition.equals(that.filterCondition) : that.filterCondition != null)</span>
<span class="nc" id="L763">            return false;</span>
<span class="nc bnc" id="L764" title="All 6 branches missed.">        if (partitionDesc != null ? !partitionDesc.equalsRaw(that.partitionDesc) : that.partitionDesc != null)</span>
<span class="nc" id="L765">            return false;</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">        return capacity == that.capacity;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="nc bnc" id="L771" title="All 2 branches missed.">        if (this == o)</span>
<span class="nc" id="L772">            return true;</span>
<span class="nc bnc" id="L773" title="All 4 branches missed.">        if (o == null || getClass() != o.getClass())</span>
<span class="nc" id="L774">            return false;</span>

<span class="nc" id="L776">        DataModelDesc modelDesc = (DataModelDesc) o;</span>

<span class="nc bnc" id="L778" title="All 2 branches missed.">        if (!name.equals(modelDesc.name))</span>
<span class="nc" id="L779">            return false;</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">        if (!getRootFactTable().equals(modelDesc.getRootFactTable()))</span>
<span class="nc" id="L781">            return false;</span>

<span class="nc" id="L783">        return true;</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L788">        int result = 0;</span>
<span class="nc" id="L789">        result = 31 * result + name.hashCode();</span>
<span class="nc" id="L790">        result = 31 * result + getRootFactTable().hashCode();</span>
<span class="nc" id="L791">        return result;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L796">        return &quot;DataModelDesc [name=&quot; + name + &quot;]&quot;;</span>
    }

    public String getResourcePath() {
<span class="nc" id="L800">        return concatResourcePath(resourceName());</span>
    }

    public static String concatResourcePath(String descName) {
<span class="nc" id="L804">        return ResourceStore.DATA_MODEL_DESC_RESOURCE_ROOT + &quot;/&quot; + descName + MetadataConstants.FILE_SURFIX;</span>
    }

    public List&lt;ModelDimensionDesc&gt; getDimensions() {
<span class="fc" id="L808">        return dimensions;</span>
    }

    public String[] getMetrics() {
<span class="fc" id="L812">        return metrics;</span>
    }

    public void setDimensions(List&lt;ModelDimensionDesc&gt; dimensions) {
<span class="nc" id="L816">        this.dimensions = dimensions;</span>
<span class="nc" id="L817">    }</span>

    public void setMetrics(String[] metrics) {
<span class="nc" id="L820">        this.metrics = metrics;</span>
<span class="nc" id="L821">    }</span>

    public String getProject() {
<span class="fc" id="L824">        return ProjectManager.getInstance(getConfig()).getProjectOfModel(this.getName()).getName();</span>
    }

    public ProjectInstance getProjectInstance() {
<span class="nc" id="L828">        return ProjectManager.getInstance(getConfig()).getProjectOfModel(this.getName());</span>
    }

    public String getProjectName() {
<span class="nc" id="L832">        return projectName;</span>
    }

    public void setProjectName(String projectName) {
<span class="nc" id="L836">        this.projectName = projectName;</span>
<span class="nc" id="L837">    }</span>

    public static DataModelDesc getCopyOf(DataModelDesc orig) {
<span class="fc" id="L840">        return copy(orig, new DataModelDesc());</span>
    }
    
    public static DataModelDesc copy(DataModelDesc orig, DataModelDesc copy) {
<span class="fc" id="L844">        copy.config = orig.config;</span>
<span class="fc" id="L845">        copy.name = orig.name;</span>
<span class="fc" id="L846">        copy.isDraft = orig.isDraft;</span>
<span class="fc" id="L847">        copy.owner = orig.owner;</span>
<span class="fc" id="L848">        copy.description = orig.description;</span>
<span class="fc" id="L849">        copy.rootFactTable = orig.rootFactTable;</span>
<span class="fc" id="L850">        copy.rootFactTableAlias = orig.rootFactTableAlias;</span>
<span class="fc" id="L851">        copy.joinTables = orig.joinTables;</span>
<span class="fc" id="L852">        copy.dimensions = orig.dimensions;</span>
<span class="fc" id="L853">        copy.metrics = orig.metrics;</span>
<span class="fc" id="L854">        copy.filterCondition = orig.filterCondition;</span>
<span class="fc" id="L855">        copy.capacity = orig.capacity;</span>
<span class="fc" id="L856">        copy.projectName = orig.projectName;</span>
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">        if (orig.getPartitionDesc() != null) {</span>
<span class="fc" id="L858">            copy.partitionDesc = PartitionDesc.getCopyOf(orig.getPartitionDesc());</span>
        }
<span class="fc" id="L860">        copy.updateRandomUuid();</span>
<span class="fc" id="L861">        return copy;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>